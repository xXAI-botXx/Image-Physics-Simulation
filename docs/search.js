window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "img_phy_sim", "modulename": "img_phy_sim", "kind": "module", "doc": "<p>IPS: Image Physical Simulation Package</p>\n\n<p>This package provides a suite of tools for simulating, analyzing, and visualizing\nrays (beams) in 2D images, along with general-purpose image and mathematical utilities.\nIt is designed for research workflows involving instance segmentation, ray tracing,\nand image-based simulations, but can also be used in general image processing tasks.</p>\n\n<p>Submodules:</p>\n\n<ul>\n<li><code>ray_tracing</code><br>\nTools for tracing rays through images with walls or obstacles,\nhandling reflections, scaling, and visualization.<br>\nKey functionalities:\n<ul>\n<li>trace_beam / trace_beams</li>\n<li>calc_reflection</li>\n<li>get_wall_map</li>\n<li>draw_rays</li>\n<li>scale_rays</li>\n<li>Utilities for merging rays, printing info, or getting pixel coordinates</li>\n</ul></li>\n</ul>\n\n<ul>\n<li><p><code>math</code><br>\nUtilities for 2D geometry, coordinate transformations, and vector math.\nProvides functions for angle-to-vector conversions, normalization, and\nworking with linear degree ranges.<br>\nKey functionalities:</p>\n\n<ul>\n<li>degree_to_vector / vector_to_degree</li>\n<li>get_linear_degree_range</li>\n<li>normalize_point / denormalize_point</li>\n</ul></li>\n<li><p><code>img</code><br>\nImage I/O, visualization, and analysis utilities.\nIncludes functions for loading, saving, displaying, and annotating images,\ncomparing predictions with ground truth, and plotting block-wise or line-wise\nstatistics.<br>\nKey functionalities:</p>\n\n<ul>\n<li>open / save</li>\n<li>imshow / advanced_imshow / show_images / show_samples</li>\n<li>plot_image_with_values / show_image_with_line_and_profile</li>\n<li>get_width_height / get_bit_depth</li>\n</ul></li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Prepare an environment image using <code>img.open()</code> or generate it programmatically.</li>\n<li>Trace beams using <code>ray_tracing.trace_beams()</code> with specified start positions,\ndirections, and wall values.</li>\n<li>Visualize the rays on images with <code>ray_tracing.draw_rays()</code>.</li>\n<li>Use <code>img</code> utilities for inspecting, annotating, or comparing images.</li>\n<li>Use <code>math</code> utilities for vector and angle calculations or normalization.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>OpenCV (cv2)</li>\n<li>matplotlib</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">img_phy_sim</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ips</span>\n\n<span class=\"c1\"># Load image</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;scene.png&quot;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Trace beams</span>\n<span class=\"n\">rays</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">trace_beams</span><span class=\"p\">(</span>\n    <span class=\"n\">rel_position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">),</span>\n    <span class=\"n\">img_src</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"p\">,</span>\n    <span class=\"n\">directions_in_degree</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">45</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">135</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Draw rays</span>\n<span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">draw_rays</span><span class=\"p\">(</span><span class=\"n\">rays</span><span class=\"p\">,</span> <span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Display result</span>\n<span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n"}, {"fullname": "img_phy_sim.img", "modulename": "img_phy_sim.img", "kind": "module", "doc": "<p><strong>Image Input, Output, and Visualization Utilities</strong></p>\n\n<p>This module provides a comprehensive set of tools for loading, saving, displaying,\nand analyzing images, particularly for scientific and machine learning workflows.\nIt supports grayscale and color images, normalization, inversion, block-wise\nstatistics, and flexible visualization options for single or multiple images.</p>\n\n<p>The core idea is to provide an easy interface for inspecting and comparing images,\ngenerating informative visualizations, and preparing image data for further processing.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Load and save images with optional normalization</li>\n<li>Display images with flexible size, colormap, and axis options</li>\n<li>Compare multiple sets of images (input, prediction, ground truth, difference)</li>\n<li>Advanced multi-image visualization with custom layouts and titles</li>\n<li>Annotate images with block-wise mean values for quick inspection</li>\n<li>Highlight specific rows or columns and plot their pixel profiles</li>\n<li>Utility functions to get image properties (bit depth, width, height)</li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Load images using <code>open()</code> or read multiple paths via <code>show_images()</code>.</li>\n<li>Visualize single or multiple images using <code>imshow()</code> or <code>advanced_imshow()</code>.</li>\n<li>Compare predictions with ground truth using <code>show_samples()</code>.</li>\n<li>Annotate blocks or highlight pixel profiles using\n<code>plot_image_with_values()</code> and <code>show_image_with_line_and_profile()</code>.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>cv2 (OpenCV)</li>\n<li>matplotlib</li>\n<li>scikit-image</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;example.png&quot;</span><span class=\"p\">,</span> <span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">img</span> <span class=\"o\">*</span> <span class=\"mi\">255</span>  <span class=\"c1\"># optional scaling</span>\n<span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n<span class=\"n\">show_samples</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">pred_img</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">ground_truth</span><span class=\"p\">],</span> <span class=\"n\">model_name</span><span class=\"o\">=</span><span class=\"s2\">&quot;MyModel&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s2\">&quot;gray&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">line_values</span> <span class=\"o\">=</span> <span class=\"n\">show_image_with_line_and_profile</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s2\">&quot;row&quot;</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>get_bit_depth(img)                   - Return bit depth of image dtype.</li>\n<li>get_width_height(img, channels_before=0) - Return (width, height) of an image.</li>\n<li>open(src, should_scale=False, should_print=True) - Load an image from disk.</li>\n<li>save(img, src, should_scale=False)  - Save an image to disk.</li>\n<li>imshow(img, size=8, axis_off=True, cmap=\"gray\") - Display an image.</li>\n<li>show_samples(input_samples, pred_samples, real_samples, ...) - Compare multiple images.</li>\n<li>advanced_imshow(img, title=None, image_width=10, ...) - Display single or batch images with customization.</li>\n<li>show_images(image_paths, title=None, image_width=5, ...) - Load and display images from paths.</li>\n<li>plot_image_with_values(img, block_size=8, ...) - Annotate image with block-wise mean values.</li>\n<li>show_image_with_line_and_profile(imgs, axis='row', ...) - Highlight a row/column and plot pixel values.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.img.get_bit_depth", "modulename": "img_phy_sim.img", "qualname": "get_bit_depth", "kind": "function", "doc": "<p>Retrieve the bit depth of an image based on its NumPy data type.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Input image array.</p>\n\n<p>Returns:\n    int or str: Bit depth of the image (8, 16, 32, or 64).\n                Returns \"unknown\" if the data type is not recognized.</p>\n\n<p>Notes:\n    The mapping is defined for common image dtypes:\n        - np.uint8   \u2192  8-bit\n        - np.uint16  \u2192 16-bit\n        - np.int16   \u2192 16-bit\n        - np.float32 \u2192 32-bit\n        - np.float64 \u2192 64-bit</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.get_width_height", "modulename": "img_phy_sim.img", "qualname": "get_width_height", "kind": "function", "doc": "<p>Extract the width and height of an image, optionally offset by leading channels.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Input image array.\n    channels_before (int, optional): Offset in the shape dimension if\n                                     channels precede height and width\n                                     (default: 0).</p>\n\n<p>Returns:\n    tuple: (width, height) of the image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>img.shape = (256, 512)\n      get_width_height(img)\n          (512, 256)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">channels_before</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.open", "modulename": "img_phy_sim.img", "qualname": "open", "kind": "function", "doc": "<p>Load a grayscale image from a file path.</p>\n\n<p>Parameters:\n    src (str): Path to the image file.\n    should_scale (bool, optional): If True, scale pixel values to [0, 1]\n                                   according to bit depth (default: False).\n    should_print (bool, optional): If True, print image info to console\n                                   (default: True).</p>\n\n<p>Returns:\n    numpy.ndarray: Loaded grayscale image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>img = open(\"example.png\", should_scale=True)\n          Loaded Image:\n              - Image size: 512x256\n              - Bit depth: 8-bit\n              - Dtype: float64</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">should_print</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.save", "modulename": "img_phy_sim.img", "qualname": "save", "kind": "function", "doc": "<p>Save an image to disk.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image to save.\n    src (str): Destination file path.\n    should_scale (bool, optional): If True, scale pixel values to [0, 1]\n                                   before saving (default: False).</p>\n\n<p>Notes:\n    - The function uses OpenCV\u2019s <code>cv2.imwrite</code> for saving.\n    - The scaling logic divides by the maximum value representable\n      by the bit depth, similar to the <code>open()</code> function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.imshow", "modulename": "img_phy_sim.img", "qualname": "imshow", "kind": "function", "doc": "<p>Display an image using Matplotlib.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image to display.\n    size (int, optional): Display size in inches (default: 8).\n    axis_off (bool, optional): If True, hides the axes (default: True).\n    cmap (str, optional): Colormap name.\n                          Use 'random' for a random Matplotlib colormap (default: 'gray').</p>\n\n<p>Behavior:\n    - If <code>img</code> has 3 channels, it is converted from BGR to RGB.\n    - If <code>cmap='random'</code>, a random colormap is chosen and possibly reversed.\n    - Maintains the aspect ratio based on image dimensions.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>imshow(img, cmap='random')\n          # Displays the image with a randomly selected colormap.</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">axis_off</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_samples", "modulename": "img_phy_sim.img", "qualname": "show_samples", "kind": "function", "doc": "<p>Display multiple sets of sample images (input, prediction, ground truth, difference)\nside by side for visual comparison.</p>\n\n<p>The function can load images from file paths or accept NumPy arrays directly.\nIt arranges them in a grid and can optionally normalize, invert, or save the output.</p>\n\n<p>Parameters:\n    input_samples (list[str] or list[np.ndarray]): Input sample images.\n    pred_samples (list[str] or list[np.ndarray]): Model prediction images.\n    real_samples (list[str] or list[np.ndarray]): Ground truth images.\n    model_name (str, optional): Name of the model to display in titles (default: \"Model\").\n    n_samples (int, optional): Number of sample groups to display (default: 3).\n    n_cols (int, optional): Number of columns per sample group (default: 4).\n                            Typically: Input | Prediction | Ground Truth | Difference.\n    image_width (int, optional): Width of one image in inches (default: 4).\n    cmap (str, optional): Colormap for displaying grayscale images (default: \"gray\").\n    normalize (bool, optional): Whether to normalize pixel values to [0, 1] (default: True).\n    invert (bool, optional): Whether to invert pixel values (255 - img) (default: False).\n    axis (bool, optional): Whether to show image axes (default: False).\n    save_to (str, optional): Path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.3).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.2).\n    use_original_style (bool, optional): If True, preserves the current matplotlib style (default: False).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_samples(inputs, preds, reals, model_name=\"UNet\", n_samples=5, cmap=\"gray\")</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_samples</span>,</span><span class=\"param\">\t<span class=\"n\">pred_samples</span>,</span><span class=\"param\">\t<span class=\"n\">real_samples</span>,</span><span class=\"param\">\t<span class=\"n\">model_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;Model&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">n_cols</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.advanced_imshow", "modulename": "img_phy_sim.img", "qualname": "advanced_imshow", "kind": "function", "doc": "<p>Display one or multiple images in a flexible and configurable grid.</p>\n\n<p>This function supports multiple color spaces, automatic reshaping of \ninput tensors, batch display, color inversion, and saving to disk.</p>\n\n<p>Parameters:\n    img (np.ndarray): Input image or batch of images.\n                      Accepted shapes:\n                          [H, W], [H, W, C], [N, H, W], or [N, H, W, C].\n    title (str or list[str], optional): Overall or per-image titles.\n    image_width (int, optional): Width of each image in inches (default: 10).\n    axis (bool, optional): Whether to show axes (default: False).\n    color_space (str, optional): Color space of the image: \"RGB\", \"BGR\", \"gray\", or \"HSV\" (default: \"RGB\").\n    cmap (str, optional): Matplotlib colormap for grayscale images (default: None).\n    cols (int, optional): Number of columns in the subplot grid (default: 1).\n    save_to (str, optional): File path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.2).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.2).\n    use_original_style (bool, optional): Keep current Matplotlib style if True (default: False).\n    invert (bool, optional): Invert color values (default: False).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>advanced_imshow(batch_images, cols=3, color_space=\"BGR\", title=\"Predictions\")</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">color_space</span><span class=\"o\">=</span><span class=\"s1\">&#39;RGB&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_images", "modulename": "img_phy_sim.img", "qualname": "show_images", "kind": "function", "doc": "<p>Load and display multiple images from disk using <code>advanced_imshow</code>.</p>\n\n<p>Parameters:\n    image_paths (list[str]): List of file paths to load.\n    title (str or list[str], optional): Plot title(s).\n    image_width (int, optional): Width of each image (default: 5).\n    axis (bool, optional): Whether to display axes (default: False).\n    color_space (str, optional): Color space to convert images to.\n                                 One of: \"gray\", \"rgb\", \"hsv\", \"bgr\" (default: \"gray\").\n    cmap (str, optional): Colormap for grayscale images (default: None).\n    cols (int, optional): Number of columns in the grid (default: 2).\n    save_to (str, optional): Path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.01).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.01).\n    use_original_style (bool, optional): Keep current Matplotlib style (default: False).\n    invert (bool, optional): Whether to invert images (default: False).</p>\n\n<p>Returns:\n    np.ndarray: Loaded images stacked as an array.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_images([\"img1.png\", \"img2.png\"], color_space=\"rgb\", cols=2)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_paths</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">color_space</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.plot_image_with_values", "modulename": "img_phy_sim.img", "qualname": "plot_image_with_values", "kind": "function", "doc": "<p>Plot an image with annotated mean values over non-overlapping blocks.</p>\n\n<p>Each block represents the mean pixel intensity of its region. The mean\nvalues are displayed as text annotations directly on the image.</p>\n\n<p>Parameters:\n    img (np.ndarray): 2D grayscale image (H, W) or 3D single-channel image (H, W, 1).\n    block_size (int or tuple, optional): Size of each block (default: 8).\n    cmap (str, optional): Matplotlib colormap (default: \"gray\").\n    title (str, optional): Plot title (default: None).\n    font_size (int, optional): Font size of value annotations (default: 6).\n    save_to (str, optional): Path to save the figure (default: None).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<pre><code><div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">imshow</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">plot_image_with_values</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">cv2</span>\n\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;example.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">IMREAD_GRAYSCALE</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Mean Block Values&#39;</span><span class=\"p\">,</span> <span class=\"n\">font_size</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n\n\nOr:\n\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">nrows</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">ncols</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">))</span>\n<span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">img_1</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">input_samples</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Input&quot;</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s2\">&quot;gray&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_1</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_2</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">pred_model</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">model_name</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_2</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_3</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">real</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;ground truth&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_3</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_4</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">pred_model</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Difference&quot;</span><span class=\"p\">,</span> <span class=\"n\">sub_image</span><span class=\"o\">=</span><span class=\"n\">real</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">])</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_4</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">])</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">8</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">font_size</span><span class=\"o\">=</span><span class=\"mi\">6</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_image_with_line_and_profile", "modulename": "img_phy_sim.img", "qualname": "show_image_with_line_and_profile", "kind": "function", "doc": "<p>Display one or multiple grayscale images with a highlighted line (row or column)\nand plot the corresponding pixel intensity profile below or beside each image.</p>\n\n<p>Parameters:\n    imgs (list[np.ndarray]): List of grayscale images to analyze.\n    axis (str, optional): Direction of the line (\"row\" or \"column\") (default: \"row\").\n    index (int, optional): Index of the selected line. If None, the central line is used (default: None).\n    titles (list[str], optional): Titles for each image (default: [\"Image 1\", \"Image 2\", ...]).\n    figsize (tuple, optional): Figure size per image pair (default: (10, 4)).</p>\n\n<p>Returns:\n    list[np.ndarray]: List of pixel intensity profiles corresponding to the selected line in each image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_image_with_line_and_profile(\n          ...     imgs=[img_input, img_pred, img_gt],\n          ...     axis=\"row\",\n          ...     titles=[\"Input\", \"Prediction\", \"Ground Truth\"]\n          ... )</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">imgs</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;row&#39;</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">titles</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math", "modulename": "img_phy_sim.math", "kind": "module", "doc": "<p><strong>Mathematical and Geometric Utility Functions</strong></p>\n\n<p>This module provides lightweight mathematical helper functions for 2D geometry\nand angle-based computations. It is designed to support higher-level operations\nsuch as beam tracing, image-based simulations, and coordinate normalization.</p>\n\n<p>The functions focus on conversions between angular and Cartesian representations,\nas well as normalization and denormalization of image coordinates.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Generate evenly spaced degree ranges for directional sampling</li>\n<li>Convert between degrees and 2D unit vectors</li>\n<li>Convert 2D vectors back to degree angles</li>\n<li>Normalize and denormalize 2D points for image-based coordinate systems</li>\n</ul>\n\n<p>Typical use cases:</p>\n\n<ul>\n<li>Generating input directions for beam tracing or ray simulation</li>\n<li>Converting between angular and vector representations in geometric algorithms</li>\n<li>Preparing coordinates for normalized image processing workflows</li>\n</ul>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>math</li>\n<li>numpy</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">math</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">pi</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">math_utils</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">get_linear_degree_range</span><span class=\"p\">,</span>\n    <span class=\"n\">degree_to_vector</span><span class=\"p\">,</span>\n    <span class=\"n\">vector_to_degree</span><span class=\"p\">,</span>\n    <span class=\"n\">normalize_point</span><span class=\"p\">,</span>\n    <span class=\"n\">denormalize_point</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Generate sample directions</span>\n<span class=\"n\">directions</span> <span class=\"o\">=</span> <span class=\"n\">get_linear_degree_range</span><span class=\"p\">(</span><span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mi\">45</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert each to a 2D vector</span>\n<span class=\"n\">vectors</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">degree_to_vector</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">directions</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Convert back to degrees</span>\n<span class=\"n\">recovered</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">vector_to_degree</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">vectors</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Normalize and denormalize a point</span>\n<span class=\"n\">p_norm</span> <span class=\"o\">=</span> <span class=\"n\">normalize_point</span><span class=\"p\">((</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">),</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n<span class=\"n\">p_pixel</span> <span class=\"o\">=</span> <span class=\"n\">denormalize_point</span><span class=\"p\">(</span><span class=\"n\">p_norm</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>get_linear_degree_range(...) - Generate evenly spaced degrees within a range.</li>\n<li>degree_to_vector(...)        - Convert a degree angle to a 2D unit vector.</li>\n<li>vector_to_degree(...)        - Convert a 2D vector into its corresponding degree.</li>\n<li>normalize_point(...)         - Normalize a 2D point to [0, 1] range.</li>\n<li>denormalize_point(...)       - Denormalize a 2D point to pixel coordinates.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.math.get_linear_degree_range", "modulename": "img_phy_sim.math", "qualname": "get_linear_degree_range", "kind": "function", "doc": "<p>Generate a list of degrees within a linear range.</p>\n\n<p>Parameters:\n    start (int, optional): Starting degree (default is 0).\n    stop (int, optional): Ending degree (default is 360).\n    step_size (int, optional): Step size between degrees (default is 10).\n    offset (int, optional): Offset to add to each degree value (default is 0).</p>\n\n<p>Returns:\n    list: List of degree values adjusted by offset and modulo 360.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">stop</span><span class=\"o\">=</span><span class=\"mi\">360</span>, </span><span class=\"param\"><span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.degree_to_vector", "modulename": "img_phy_sim.math", "qualname": "degree_to_vector", "kind": "function", "doc": "<p>Convert a degree angle to a 2D unit vector.</p>\n\n<p>Parameters:\n    degree (float): Angle in degrees.</p>\n\n<p>Returns:\n    list: 2D vector [cos(degree), sin(degree)].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">degree</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.vector_to_degree", "modulename": "img_phy_sim.math", "qualname": "vector_to_degree", "kind": "function", "doc": "<p>Convert a 2D vector into its corresponding degree angle.</p>\n\n<p>Parameters:\n    vector (tuple): 2D vector (x, y).</p>\n\n<p>Returns:\n    int: Angle in degrees within the range [0, 360).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.normalize_point", "modulename": "img_phy_sim.math", "qualname": "normalize_point", "kind": "function", "doc": "<p>Normalize a 2D point to the range [0, 1].</p>\n\n<p>Parameters:\n    point (tuple): (x, y) coordinates of the point.\n    width (int): Image or grid width.\n    height (int): Image or grid height.</p>\n\n<p>Returns:\n    tuple: Normalized point (x / (width - 1), y / (height - 1)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.denormalize_point", "modulename": "img_phy_sim.math", "qualname": "denormalize_point", "kind": "function", "doc": "<p>Denormalize a 2D point from normalized coordinates back to pixel coordinates.</p>\n\n<p>Parameters:\n    point (tuple): Normalized (x, y) coordinates.\n    width (int): Image or grid width.\n    height (int): Image or grid height.</p>\n\n<p>Returns:\n    tuple: Denormalized point (x * (width - 1), y * (height - 1)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing", "modulename": "img_phy_sim.ray_tracing", "kind": "module", "doc": "<p><strong>Beam Tracing and Visualization Utilities</strong></p>\n\n<p>This module provides a set of tools for simulating and visualizing the propagation\nof rays (beams) through 2D images that may contain reflective or obstructive walls.\nIt includes methods for tracing ray paths, handling reflections, scaling and\nnormalizing ray coordinates, and drawing the resulting beam paths onto images.</p>\n\n<p>The core idea is to represent a 2D environment as an image where certain pixel\nvalues correspond to walls or obstacles. Rays are emitted from a relative position\nand traced in specified directions, optionally reflecting off walls multiple times.\nThe results can then be visualized or further processed.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Ray tracing with customizable reflection order and wall detection</li>\n<li>Support for relative and absolute coordinate systems</li>\n<li>Ray scaling utilities for normalization or resizing</li>\n<li>Image rendering functions to visualize rays, walls, and reflection paths</li>\n<li>Flexible output modes: single image, multi-channel, or multiple separate images</li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Use <code>trace_beams()</code> to simulate multiple beams across an image.</li>\n<li>Render the rays on an image using <code>draw_rays()</code>.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>cv2 (OpenCV)</li>\n<li>internal math + img modules</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;scene.png&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">rays</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">trace_beams</span><span class=\"p\">(</span>\n    <span class=\"n\">rel_position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">),</span>\n    <span class=\"n\">img_src</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"p\">,</span>\n    <span class=\"n\">directions_in_degree</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">45</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">135</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"p\">)</span>\n<span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">draw_rays</span><span class=\"p\">(</span><span class=\"n\">rays</span><span class=\"p\">,</span> <span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>print_rays_info(...)  - Pritn informations about created rays.</li>\n<li>save(...)  - Save rays into a file.</li>\n<li>open(...)  - Load saved rays.</li>\n<li>merge(...)  - Merge 2 or more rays together.</li>\n<li>get_all_pixel_coordinates_in_between(...)  - Use brahams algorithm for getting any line in a quantizied space.</li>\n<li>get_wall_map(...)  - Extract edges and get the wall-map with direction angles of walls. </li>\n<li>update_pixel_position(...)  - Get the next pixel to come from one point to another in a quantizied system.</li>\n<li>calc_reflection(...)  - Calculate the reflexion of 2 vectors.</li>\n<li>get_img_border_vector(...)  - Get the vector of a border of the image.</li>\n<li>trace_beam(...)  - Trace a single beam with reflexions.</li>\n<li>trace_beams(...)  - Trace multiple beams with reflections through an image.</li>\n<li>scale_rays(...)   - Normalize or rescale ray coordinates.</li>\n<li>draw_rectangle_with_thickness(...) - Draw filled or thick rectangles.</li>\n<li>draw_line_or_point(...) - Draw a single point or a line segment.</li>\n<li>draw_rays(...)    - Visualize traced rays as images or channels.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator", "kind": "class", "doc": "<p>A container class to save every step of a ray tracing process.</p>\n"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.__init__", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.__init__", "kind": "function", "doc": "<p>Initialize a RayIterator instance.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>other_ray_iterator (RayIterator, optional): \nAn existing RayIterator to copy. If provided, creates a deep copy \nof the other iterator's rays_collection. If None, creates an empty iterator.</li>\n</ul>\n\n<p>Returns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">other_ray_iterator</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.len_iterations", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.len_iterations", "kind": "function", "doc": "<p>Get the total number of iterations/time-steps stored.</p>\n\n<p>Returns:\nint: \n    Number of iterations in the rays_collection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.add_iteration", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.add_iteration", "kind": "function", "doc": "<p>Add a new iteration (collection of rays) to the iterator.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays (list): Collection of rays to add as a new iteration.\nFormat: rays[ray][beam][point] = (x, y)</li>\n</ul>\n\n<p>Returns:\nRayIterator: self, for method chaining.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.add_rays", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.add_rays", "kind": "function", "doc": "<p>Add rays to the every iteration (in-place modification).\nIf one iterator have less steps, the last step will be used for all other iterations.\nWhich equals no change for those iterations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays (list): Rays to add to the latest iteration.\nFormat: rays[ray][beam][point] = (x, y)</li>\n</ul>\n\n<p>Returns:\nlist: The updated rays_collection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.print_info", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.print_info", "kind": "function", "doc": "<p>Print statistical information about the ray collections.</p>\n\n<p>Displays:</p>\n\n<ul>\n<li>Number of iterations</li>\n<li>Information about the latest iteration's rays including:\n<ul>\n<li>Number of rays, beams, reflexions, and points</li>\n<li>Mean, median, max, min, and variance for beams per ray, \nreflexions per ray, and points per beam</li>\n<li>Value range for x and y coordinates</li>\n</ul></li>\n</ul>\n\n<p>Returns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.reduce_to_x_steps", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.reduce_to_x_steps", "kind": "function", "doc": "<p>Reduce the number of stored iterations to approximately x_steps.</p>\n\n<p>Uses linear sampling to keep representative iterations while reducing\nmemory usage. If x_steps is greater than current iterations, does nothing.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>x_steps (int): \nDesired number of iterations to keep.</li>\n</ul>\n\n<p>Returns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_steps</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.apply_and_update", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.apply_and_update", "kind": "function", "doc": "<p>Apply a function to each iteration's rays and update in-place.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>func (callable): \nFunction that takes a rays collection and returns a modified rays collection. \nWill be applied to each iteration.</li>\n</ul>\n\n<p>Returns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.apply_and_return", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.apply_and_return", "kind": "function", "doc": "<p>Apply a function to each iteration's rays and return results.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>func (callable): \nFunction that takes a rays collection and returns some result. \nWill be applied to each iteration.</li>\n</ul>\n\n<p>Returns:\nlist: \n    Results of applying func to each iteration's rays.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.RayIterator.get_iteration", "modulename": "img_phy_sim.ray_tracing", "qualname": "RayIterator.get_iteration", "kind": "function", "doc": "<p>Get a specific iteration's rays collection.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>index (int): \nIndex of the iteration to retrieve. Supports negative indexing (e.g., -1 for last iteration).</li>\n</ul>\n\n<p>Returns:\nlist: \n    Rays collection at the specified iteration.</p>\n\n<p>Raises: \nIndexError: If index is out of range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.print_rays_info", "modulename": "img_phy_sim.ray_tracing", "qualname": "print_rays_info", "kind": "function", "doc": "<p>Print statistical information about a collection of rays.</p>\n\n<p>Each ray consists of multiple beams, and each beam consists of multiple points.\nThe function computes and displays statistics such as:</p>\n\n<ul>\n<li>Number of rays, beams, reflexions, and points</li>\n<li>Mean, median, max, min, and variance for beams per ray, reflexions per ray, and points per beam</li>\n<li>Value range for x and y coordinates</li>\n</ul>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays (list): \nNested list structure representing rays. Format: rays[ray][beam][point] = (x, y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.save", "modulename": "img_phy_sim.ray_tracing", "qualname": "save", "kind": "function", "doc": "<p>Save a list of rays to a text file.</p>\n\n<p>The rays are serialized using a simple text-based format. \nEach ray is delimited by '>' and '&lt;', and each point is represented as \"x | y\".</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>path (str): \nPath to the file where data should be saved. If no '.txt' extension is present, it will be appended automatically.</li>\n<li>rays (list): \nNested list structure representing rays. Format: rays[ray][beam][point] = (x, y)</li>\n</ul>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.open", "modulename": "img_phy_sim.ray_tracing", "qualname": "open", "kind": "function", "doc": "<p>Open and parse a ray text file into a structured list.</p>\n\n<p>The file is expected to follow the same format as produced by <code>save()</code>.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>path (str): \nPath to the .txt file containing ray data.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nNested list structure representing rays. Format: rays[ray][beam][point] = (x, y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">is_iterator</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.merge", "modulename": "img_phy_sim.ray_tracing", "qualname": "merge", "kind": "function", "doc": "<p>Merge multiple ray datasets into a single list.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays_1 (list): \nFirst set of rays.</li>\n<li>rays_2 (list): \nSecond set of rays. </li>\n<li>*other_rays_ (list): \nAdditional ray lists to merge.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nCombined list of all rays.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rays_1</span>, </span><span class=\"param\"><span class=\"n\">rays_2</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">other_rays_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_all_pixel_coordinates_in_between", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_all_pixel_coordinates_in_between", "kind": "function", "doc": "<p>Get all pixel coordinates along a line between two points using Bresenham\u2019s algorithm.</p>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm\">https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a></p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>x1 (int): \nStarting x-coordinate.</li>\n<li>y1 (int): \nStarting y-coordinate.</li>\n<li>x2 (int): \nEnding x-coordinate.</li>\n<li>y2 (int): \nEnding y-coordinate.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nList of (x, y) tuples representing all pixels between the start and end points</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span>, </span><span class=\"param\"><span class=\"n\">y1</span>, </span><span class=\"param\"><span class=\"n\">x2</span>, </span><span class=\"param\"><span class=\"n\">y2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_wall_map", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_wall_map", "kind": "function", "doc": "<p>Generate a wall map where each pixel encodes the wall orientation (in degrees).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>img (numpy.ndarray): \nInput image representing scene or segmentation mask.</li>\n<li>wall_values (list, optional): \nSpecific pixel values considered as walls. If None, all non-zero pixels are treated as walls.</li>\n<li>thickness (int, optional): \nThickness of wall lines (default is 1).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>numpy.ndarray: \n2D array (same width and height as input) \nwhere each wall pixel contains the wall angle in degrees (0-360), \nand non-wall pixels are set to infinity (np.inf).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.update_pixel_position", "modulename": "img_phy_sim.ray_tracing", "qualname": "update_pixel_position", "kind": "function", "doc": "<p>Update the pixel position of a moving point toward a target line based on direction and proximity.</p>\n\n<p>Combines the direction vector with a vector pointing toward the closest point\non the target line, ensuring pixel-wise movement (discrete steps).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>direction_in_degree (float): \nMovement direction in degrees.</li>\n<li>cur_position (tuple): \nCurrent pixel position (x, y).</li>\n<li>target_line (list): \nTarget line defined as [x1, y1, x2, y2].</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>tuple: \nUpdated pixel position (x, y).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">direction_in_degree</span>, </span><span class=\"param\"><span class=\"n\">cur_position</span>, </span><span class=\"param\"><span class=\"n\">target_line</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.calc_reflection", "modulename": "img_phy_sim.ray_tracing", "qualname": "calc_reflection", "kind": "function", "doc": "<p>Calculate the reflection of a collision vector against a wall vector.</p>\n\n<p>The reflection is computed using the wall's normal vector and the formula:\n    r = v - 2 * (v \u00b7 n) * n</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>collide_vector (array-like): \nIncoming vector (2D).</li>\n<li>wall_vector (array-like): \nWall direction vector (2D).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>numpy.ndarray: \nReflected 2D vector.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">collide_vector</span>, </span><span class=\"param\"><span class=\"n\">wall_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_img_border_vector", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_img_border_vector", "kind": "function", "doc": "<p>Determine the wall normal vector for an image border collision.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>position (tuple): \nCurrent position (x, y).</li>\n<li>max_width (int): \nImage width.</li>\n<li>max_height (int): \nImage height.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nBorder wall vector corresponding to the collision side.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">max_width</span>, </span><span class=\"param\"><span class=\"n\">max_height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.trace_beam", "modulename": "img_phy_sim.ray_tracing", "qualname": "trace_beam", "kind": "function", "doc": "<p>Trace a ray (beam) through an image with walls and reflections.</p>\n\n<p>The beam starts from a given position and follows a direction until it hits\na wall or border. On collisions, reflections are computed using wall normals.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>abs_position (tuple): \nStarting position (x, y) of the beam.</li>\n<li>img (numpy.ndarray): \nInput image or segmentation map.</li>\n<li>direction_in_degree (float): \nInitial direction angle of the beam.</li>\n<li>wall_map (numpy.ndarray): \nMap containing wall orientations in degrees.</li>\n<li>wall_values (list): \nList of pixel values representing walls.</li>\n<li>img_border_also_collide (bool, optional): \nWhether the image border acts as a collider (default: False).</li>\n<li>reflexion_order (int, optional): \nNumber of allowed reflections (default: 3).</li>\n<li>should_scale (bool, optional): \nWhether to normalize positions to [0, 1] (default: True).</li>\n<li>should_return_iterative (bool, optional): \nWhether to return a RayIterator for step-by-step analysis (default: False).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nNested list structure representing the traced ray and its reflections. \nFormat: ray[beam][point] = (x, y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">abs_position</span>,</span><span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">direction_in_degree</span>,</span><span class=\"param\">\t<span class=\"n\">wall_map</span>,</span><span class=\"param\">\t<span class=\"n\">wall_values</span>,</span><span class=\"param\">\t<span class=\"n\">img_border_also_collide</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">should_return_iterative</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.trace_beam_with_DDA", "modulename": "img_phy_sim.ray_tracing", "qualname": "trace_beam_with_DDA", "kind": "function", "doc": "<p>Trace a ray (beam) through a 2D image using a DDA (Digital Differential Analyzer)\nalgorithm with precise collision points and physically accurate reflections.</p>\n\n<p>The beam starts at a given floating-point position and marches through the grid\nuntil it intersects a wall or exits the image. For each collision, the exact\nhit position is computed using the ray Parameters t_hit, ensuring that reflected\nsegments contain meaningful geometry rather than single-point artifacts.\nReflections are computed using wall normals derived from the <code>wall_map</code>.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>abs_position (tuple of float): \nStarting position (x, y) of the beam in absolute pixel space.</li>\n<li>img (numpy.ndarray): \n2D array representing the scene. Pixel values listed in <code>wall_values</code>\nare treated as solid walls.</li>\n<li>direction_in_degree (float): \nInitial direction of the beam in degrees (0\u00b0 = right, 90\u00b0 = down).</li>\n<li>wall_map (numpy.ndarray): \nA map storing wall orientations in degrees for each pixel marked as a wall.\nThese angles define the wall normals used for reflection.</li>\n<li>wall_values (list, tuple, set, float, optional): \nPixel values identifying walls. Any pixel in this list causes a collision.\nIf None, pixel value 0.0 is treated as a wall.</li>\n<li>img_border_also_collide (bool, optional): \nIf True, the image borders behave like reflective walls. If False,\nthe ray terminates when leaving the image. Default: False.</li>\n<li>reflexion_order (int, optional): \nMaximum number of reflections. The ray can rebound this many times before\nthe function terminates. Default: 3.</li>\n<li>should_scale (bool, optional): \nIf True, all emitted points (x, y) are normalized to [0, 1] range.\nOtherwise absolute pixel positions are returned. Default: True.</li>\n<li>should_return_iterative (bool, optional): \nWhether to return a RayIterator for step-by-step analysis (default: False).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nNested list structure representing the traced ray and its reflections. \nFormat: ray[beam][point] = (x, y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">abs_position</span>,</span><span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">direction_in_degree</span>,</span><span class=\"param\">\t<span class=\"n\">wall_map</span>,</span><span class=\"param\">\t<span class=\"n\">wall_values</span>,</span><span class=\"param\">\t<span class=\"n\">img_border_also_collide</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">should_return_iterative</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.trace_beams", "modulename": "img_phy_sim.ray_tracing", "qualname": "trace_beams", "kind": "function", "doc": "<p>Trace multiple rays (beams) from a single position through an image with walls and reflections.</p>\n\n<p>Each beam starts from a given relative position and follows its assigned direction\nuntil it collides with a wall or image border. On collisions, reflections are\ncomputed based on local wall normals extracted from the image.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rel_position (tuple): \nRelative starting position (x, y) in normalized coordinates [0-1].</li>\n<li>img_src (str or numpy.ndarray): \nInput image (array or file path) used for wall detection.</li>\n<li>directions_in_degree (list): \nList of beam direction angles (in degrees).</li>\n<li>wall_values (list or float or None): \nPixel values representing walls or obstacles.</li>\n<li>wall_thickness (int, optional): \nThickness (in pixels) of detected walls (default: 0).</li>\n<li>img_border_also_collide (bool, optional): \nWhether image borders act as colliders (default: False).</li>\n<li>reflexion_order (int, optional): \nNumber of allowed reflections per beam (default: 3).</li>\n<li>should_scale_rays (bool, optional): \nWhether to normalize ray coordinates to [0, 1] (default: True).</li>\n<li>should_scale_img (bool, optional): \nWhether to scale the input image before wall detection (default: True).</li>\n<li>use_dda (bool, optional): \nWhether to use the DDA-based ray tracing method (default: True).</li>\n<li>iterative_tracking (bool, optional): \nWhether to return a RayIterator for step-by-step analysis (default: False).</li>\n<li>iterative_steps (int, optional):\nNumber of steps for iterative reduction if using iterative tracking. <code>None</code> for all steps.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nNested list of traced beams and their reflection segments. \nFormat: rays[beam][segment][point] = (x, y)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rel_position</span>,</span><span class=\"param\">\t<span class=\"n\">img_src</span>,</span><span class=\"param\">\t<span class=\"n\">directions_in_degree</span>,</span><span class=\"param\">\t<span class=\"n\">wall_values</span>,</span><span class=\"param\">\t<span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">img_border_also_collide</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_rays</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_img</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_dda</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">iterative_tracking</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">iterative_steps</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.scale_rays", "modulename": "img_phy_sim.ray_tracing", "qualname": "scale_rays", "kind": "function", "doc": "<p>Scale ray coordinates between coordinate systems or image resolutions.</p>\n\n<p>Optionally normalizes rays by old dimensions and rescales them to new ones.\nCan scale all points or just the start/end points of each beam.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays (list): \nNested list of rays in the format rays[ray][beam][point] = (x, y).</li>\n<li>max_x (float, optional): \nOriginal maximum x-value for normalization.</li>\n<li>max_y (float, optional): \nOriginal maximum y-value for normalization.</li>\n<li>new_max_x (float, optional): \nNew maximum x-value after rescaling.</li>\n<li>new_max_y (float, optional): \nNew maximum y-value after rescaling.</li>\n<li>detailed_scaling (bool, optional): \nIf True, scale every point in a beam; otherwise, only endpoints (default: True).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: \nScaled rays in the same nested format.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rays</span>,</span><span class=\"param\">\t<span class=\"n\">max_x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_max_x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_max_y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">detailed_scaling</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_rectangle_with_thickness", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_rectangle_with_thickness", "kind": "function", "doc": "<p>Draw a filled or thick rectangle on an image.</p>\n\n<p>Expands the given start and end points based on the desired thickness and\nclips coordinates to image bounds to avoid overflow.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>img (numpy.ndarray): \nImage array to draw on.</li>\n<li>start_point (tuple): \nTop-left corner of the rectangle (x, y).</li>\n<li>end_point (tuple): \nBottom-right corner of the rectangle (x, y).</li>\n<li>value (int or float): \nFill value or color intensity.</li>\n<li>thickness (int, optional): \nRectangle border thickness; \nif &lt;= 0, the rectangle is filled (default: 1).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">start_point</span>, </span><span class=\"param\"><span class=\"n\">end_point</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_line_or_point", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_line_or_point", "kind": "function", "doc": "<p>Draw either a line or a single point on an image.</p>\n\n<p>Determines whether to draw a point or a line based on whether the start and\nend coordinates are identical.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>img (numpy.ndarray): \nImage array to draw on.</li>\n<li>start_point (tuple): \nStarting pixel coordinate (x, y).</li>\n<li>end_point (tuple): \nEnding pixel coordinate (x, y).</li>\n<li>fill_value (int or float): \nValue or color used for drawing.</li>\n<li>thickness (int): \nThickness of the line or point.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">start_point</span>, </span><span class=\"param\"><span class=\"n\">end_point</span>, </span><span class=\"param\"><span class=\"n\">fill_value</span>, </span><span class=\"param\"><span class=\"n\">thickness</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_rays", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_rays", "kind": "function", "doc": "<p>Render rays onto an image or a set of images.</p>\n\n<p>Each ray can be drawn in full detail (every point) or as straight lines between\nbeam endpoints. Rays can be scaled to match image dimensions and drawn on a\nsingle image, multiple images, or separate channels.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>rays (list): \nNested list of rays in the format rays[ray][beam][point] = (x, y).</li>\n<li>detail_draw (bool, optional): \nWhether to draw every point or just beam endpoints (default: True).</li>\n<li>output_format (str, optional): \nOutput mode: \"single_image\", \"multiple_images\", or \"channels\" (default: \"single_image\").</li>\n<li>img_background (numpy.ndarray, optional): \nBackground image; if None, a blank image is created.</li>\n<li>ray_value (int, float, list, or numpy.ndarray, optional): \nPixel intensity or color per reflection (default: 255).</li>\n<li>ray_thickness (int, optional): \nThickness of the drawn lines or points (default: 1).</li>\n<li>img_shape (tuple, optional): \nShape of the generated image if no background is given (default: (256, 256)).</li>\n<li>dtype (type, optional): \nData type for the output image (default: float).</li>\n<li>standard_value (int or float, optional): \nBackground fill value (default: 0).</li>\n<li>should_scale_rays_to_image (bool, optional): \nWhether to scale ray coordinates to match the image (default: True).</li>\n<li>original_max_width (float, optional): \nOriginal image width before scaling.</li>\n<li>original_max_height (float, optional): \nOriginal image height before scaling.</li>\n<li>show_only_reflections (bool, optional): \nIf True, draws only reflected beams (default: False).</li>\n</ul>\n\n<p>Returns:\n    numpy.ndarray or list:\n        - Single image if output_format == \"single_image\" or \"channels\".\n        - List of images if output_format == \"multiple_images\".</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rays</span>,</span><span class=\"param\">\t<span class=\"n\">detail_draw</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">output_format</span><span class=\"o\">=</span><span class=\"s1\">&#39;single_image&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">img_background</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span>,</span><span class=\"param\">\t<span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">)</span>,</span><span class=\"param\">\tdtype=&lt;class &#x27;float&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">standard_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_rays_to_image</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">original_max_width</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">original_max_height</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_only_reflections</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();