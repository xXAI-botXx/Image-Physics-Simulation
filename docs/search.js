window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "img_phy_sim", "modulename": "img_phy_sim", "kind": "module", "doc": "<p>IPS: Image Physical Simulation Package</p>\n\n<p>This package provides a suite of tools for simulating, analyzing, and visualizing\nrays (beams) in 2D images, along with general-purpose image and mathematical utilities.\nIt is designed for research workflows involving instance segmentation, ray tracing,\nand image-based simulations, but can also be used in general image processing tasks.</p>\n\n<p>Submodules:</p>\n\n<ul>\n<li><code>ray_tracing</code><br>\nTools for tracing rays through images with walls or obstacles,\nhandling reflections, scaling, and visualization.<br>\nKey functionalities:\n<ul>\n<li>trace_beam / trace_beams</li>\n<li>calc_reflection</li>\n<li>get_wall_map</li>\n<li>draw_rays</li>\n<li>scale_rays</li>\n<li>Utilities for merging rays, printing info, or getting pixel coordinates</li>\n</ul></li>\n</ul>\n\n<ul>\n<li><p><code>math</code><br>\nUtilities for 2D geometry, coordinate transformations, and vector math.\nProvides functions for angle-to-vector conversions, normalization, and\nworking with linear degree ranges.<br>\nKey functionalities:</p>\n\n<ul>\n<li>degree_to_vector / vector_to_degree</li>\n<li>get_linear_degree_range</li>\n<li>normalize_point / denormalize_point</li>\n</ul></li>\n<li><p><code>img</code><br>\nImage I/O, visualization, and analysis utilities.\nIncludes functions for loading, saving, displaying, and annotating images,\ncomparing predictions with ground truth, and plotting block-wise or line-wise\nstatistics.<br>\nKey functionalities:</p>\n\n<ul>\n<li>open / save</li>\n<li>imshow / advanced_imshow / show_images / show_samples</li>\n<li>plot_image_with_values / show_image_with_line_and_profile</li>\n<li>get_width_height / get_bit_depth</li>\n</ul></li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Prepare an environment image using <code>img.open()</code> or generate it programmatically.</li>\n<li>Trace beams using <code>ray_tracing.trace_beams()</code> with specified start positions,\ndirections, and wall values.</li>\n<li>Visualize the rays on images with <code>ray_tracing.draw_rays()</code>.</li>\n<li>Use <code>img</code> utilities for inspecting, annotating, or comparing images.</li>\n<li>Use <code>math</code> utilities for vector and angle calculations or normalization.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>OpenCV (cv2)</li>\n<li>matplotlib</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ips.img</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ips_img</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ips.math</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ips_math</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">ips.ray_tracing</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">ips_ray</span>\n\n<span class=\"c1\"># Load image</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">ips_img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;scene.png&quot;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Trace beams</span>\n<span class=\"n\">rays</span> <span class=\"o\">=</span> <span class=\"n\">ips_ray</span><span class=\"o\">.</span><span class=\"n\">trace_beams</span><span class=\"p\">(</span>\n    <span class=\"n\">rel_position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">),</span>\n    <span class=\"n\">img_src</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"p\">,</span>\n    <span class=\"n\">directions_in_degree</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">45</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">135</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Draw rays</span>\n<span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">ips_ray</span><span class=\"o\">.</span><span class=\"n\">draw_rays</span><span class=\"p\">(</span><span class=\"n\">rays</span><span class=\"p\">,</span> <span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Display result</span>\n<span class=\"n\">ips_img</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n"}, {"fullname": "img_phy_sim.img", "modulename": "img_phy_sim.img", "kind": "module", "doc": "<p><strong>Image Input, Output, and Visualization Utilities</strong></p>\n\n<p>This module provides a comprehensive set of tools for loading, saving, displaying,\nand analyzing images, particularly for scientific and machine learning workflows.\nIt supports grayscale and color images, normalization, inversion, block-wise\nstatistics, and flexible visualization options for single or multiple images.</p>\n\n<p>The core idea is to provide an easy interface for inspecting and comparing images,\ngenerating informative visualizations, and preparing image data for further processing.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Load and save images with optional normalization</li>\n<li>Display images with flexible size, colormap, and axis options</li>\n<li>Compare multiple sets of images (input, prediction, ground truth, difference)</li>\n<li>Advanced multi-image visualization with custom layouts and titles</li>\n<li>Annotate images with block-wise mean values for quick inspection</li>\n<li>Highlight specific rows or columns and plot their pixel profiles</li>\n<li>Utility functions to get image properties (bit depth, width, height)</li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Load images using <code>open()</code> or read multiple paths via <code>show_images()</code>.</li>\n<li>Visualize single or multiple images using <code>imshow()</code> or <code>advanced_imshow()</code>.</li>\n<li>Compare predictions with ground truth using <code>show_samples()</code>.</li>\n<li>Annotate blocks or highlight pixel profiles using\n<code>plot_image_with_values()</code> and <code>show_image_with_line_and_profile()</code>.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>cv2 (OpenCV)</li>\n<li>matplotlib</li>\n<li>scikit-image</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;example.png&quot;</span><span class=\"p\">,</span> <span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">img</span> <span class=\"o\">*</span> <span class=\"mi\">255</span>  <span class=\"c1\"># optional scaling</span>\n<span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n<span class=\"n\">show_samples</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">pred_img</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">ground_truth</span><span class=\"p\">],</span> <span class=\"n\">model_name</span><span class=\"o\">=</span><span class=\"s2\">&quot;MyModel&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s2\">&quot;gray&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">line_values</span> <span class=\"o\">=</span> <span class=\"n\">show_image_with_line_and_profile</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s2\">&quot;row&quot;</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>get_bit_depth(img)                   - Return bit depth of image dtype.</li>\n<li>get_width_height(img, channels_before=0) - Return (width, height) of an image.</li>\n<li>open(src, should_scale=False, should_print=True) - Load an image from disk.</li>\n<li>save(img, src, should_scale=False)  - Save an image to disk.</li>\n<li>imshow(img, size=8, axis_off=True, cmap=\"gray\") - Display an image.</li>\n<li>show_samples(input_samples, pred_samples, real_samples, ...) - Compare multiple images.</li>\n<li>advanced_imshow(img, title=None, image_width=10, ...) - Display single or batch images with customization.</li>\n<li>show_images(image_paths, title=None, image_width=5, ...) - Load and display images from paths.</li>\n<li>plot_image_with_values(img, block_size=8, ...) - Annotate image with block-wise mean values.</li>\n<li>show_image_with_line_and_profile(imgs, axis='row', ...) - Highlight a row/column and plot pixel values.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.img.get_bit_depth", "modulename": "img_phy_sim.img", "qualname": "get_bit_depth", "kind": "function", "doc": "<p>Retrieve the bit depth of an image based on its NumPy data type.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Input image array.</p>\n\n<p>Returns:\n    int or str: Bit depth of the image (8, 16, 32, or 64).\n                Returns \"unknown\" if the data type is not recognized.</p>\n\n<p>Notes:\n    The mapping is defined for common image dtypes:\n        - np.uint8   \u2192  8-bit\n        - np.uint16  \u2192 16-bit\n        - np.int16   \u2192 16-bit\n        - np.float32 \u2192 32-bit\n        - np.float64 \u2192 64-bit</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.get_width_height", "modulename": "img_phy_sim.img", "qualname": "get_width_height", "kind": "function", "doc": "<p>Extract the width and height of an image, optionally offset by leading channels.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Input image array.\n    channels_before (int, optional): Offset in the shape dimension if\n                                     channels precede height and width\n                                     (default: 0).</p>\n\n<p>Returns:\n    tuple: (width, height) of the image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>img.shape = (256, 512)\n      get_width_height(img)\n          (512, 256)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">channels_before</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.open", "modulename": "img_phy_sim.img", "qualname": "open", "kind": "function", "doc": "<p>Load a grayscale image from a file path.</p>\n\n<p>Parameters:\n    src (str): Path to the image file.\n    should_scale (bool, optional): If True, scale pixel values to [0, 1]\n                                   according to bit depth (default: False).\n    should_print (bool, optional): If True, print image info to console\n                                   (default: True).</p>\n\n<p>Returns:\n    numpy.ndarray: Loaded grayscale image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>img = open(\"example.png\", should_scale=True)\n          Loaded Image:\n              - Image size: 512x256\n              - Bit depth: 8-bit\n              - Dtype: float64</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">should_print</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.save", "modulename": "img_phy_sim.img", "qualname": "save", "kind": "function", "doc": "<p>Save an image to disk.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image to save.\n    src (str): Destination file path.\n    should_scale (bool, optional): If True, scale pixel values to [0, 1]\n                                   before saving (default: False).</p>\n\n<p>Notes:\n    - The function uses OpenCV\u2019s <code>cv2.imwrite</code> for saving.\n    - The scaling logic divides by the maximum value representable\n      by the bit depth, similar to the <code>open()</code> function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.imshow", "modulename": "img_phy_sim.img", "qualname": "imshow", "kind": "function", "doc": "<p>Display an image using Matplotlib.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image to display.\n    size (int, optional): Display size in inches (default: 8).\n    axis_off (bool, optional): If True, hides the axes (default: True).\n    cmap (str, optional): Colormap name.\n                          Use 'random' for a random Matplotlib colormap (default: 'gray').</p>\n\n<p>Behavior:\n    - If <code>img</code> has 3 channels, it is converted from BGR to RGB.\n    - If <code>cmap='random'</code>, a random colormap is chosen and possibly reversed.\n    - Maintains the aspect ratio based on image dimensions.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>imshow(img, cmap='random')\n          # Displays the image with a randomly selected colormap.</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">8</span>, </span><span class=\"param\"><span class=\"n\">axis_off</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_samples", "modulename": "img_phy_sim.img", "qualname": "show_samples", "kind": "function", "doc": "<p>Display multiple sets of sample images (input, prediction, ground truth, difference)\nside by side for visual comparison.</p>\n\n<p>The function can load images from file paths or accept NumPy arrays directly.\nIt arranges them in a grid and can optionally normalize, invert, or save the output.</p>\n\n<p>Parameters:\n    input_samples (list[str] or list[np.ndarray]): Input sample images.\n    pred_samples (list[str] or list[np.ndarray]): Model prediction images.\n    real_samples (list[str] or list[np.ndarray]): Ground truth images.\n    model_name (str, optional): Name of the model to display in titles (default: \"Model\").\n    n_samples (int, optional): Number of sample groups to display (default: 3).\n    n_cols (int, optional): Number of columns per sample group (default: 4).\n                            Typically: Input | Prediction | Ground Truth | Difference.\n    image_width (int, optional): Width of one image in inches (default: 4).\n    cmap (str, optional): Colormap for displaying grayscale images (default: \"gray\").\n    normalize (bool, optional): Whether to normalize pixel values to [0, 1] (default: True).\n    invert (bool, optional): Whether to invert pixel values (255 - img) (default: False).\n    axis (bool, optional): Whether to show image axes (default: False).\n    save_to (str, optional): Path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.3).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.2).\n    use_original_style (bool, optional): If True, preserves the current matplotlib style (default: False).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_samples(inputs, preds, reals, model_name=\"UNet\", n_samples=5, cmap=\"gray\")</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_samples</span>,</span><span class=\"param\">\t<span class=\"n\">pred_samples</span>,</span><span class=\"param\">\t<span class=\"n\">real_samples</span>,</span><span class=\"param\">\t<span class=\"n\">model_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;Model&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">n_cols</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">normalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.3</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.advanced_imshow", "modulename": "img_phy_sim.img", "qualname": "advanced_imshow", "kind": "function", "doc": "<p>Display one or multiple images in a flexible and configurable grid.</p>\n\n<p>This function supports multiple color spaces, automatic reshaping of \ninput tensors, batch display, color inversion, and saving to disk.</p>\n\n<p>Parameters:\n    img (np.ndarray): Input image or batch of images.\n                      Accepted shapes:\n                          [H, W], [H, W, C], [N, H, W], or [N, H, W, C].\n    title (str or list[str], optional): Overall or per-image titles.\n    image_width (int, optional): Width of each image in inches (default: 10).\n    axis (bool, optional): Whether to show axes (default: False).\n    color_space (str, optional): Color space of the image: \"RGB\", \"BGR\", \"gray\", or \"HSV\" (default: \"RGB\").\n    cmap (str, optional): Matplotlib colormap for grayscale images (default: None).\n    cols (int, optional): Number of columns in the subplot grid (default: 1).\n    save_to (str, optional): File path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.2).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.2).\n    use_original_style (bool, optional): Keep current Matplotlib style if True (default: False).\n    invert (bool, optional): Invert color values (default: False).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>advanced_imshow(batch_images, cols=3, color_space=\"BGR\", title=\"Predictions\")</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">color_space</span><span class=\"o\">=</span><span class=\"s1\">&#39;RGB&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_images", "modulename": "img_phy_sim.img", "qualname": "show_images", "kind": "function", "doc": "<p>Load and display multiple images from disk using <code>advanced_imshow</code>.</p>\n\n<p>Parameters:\n    image_paths (list[str]): List of file paths to load.\n    title (str or list[str], optional): Plot title(s).\n    image_width (int, optional): Width of each image (default: 5).\n    axis (bool, optional): Whether to display axes (default: False).\n    color_space (str, optional): Color space to convert images to.\n                                 One of: \"gray\", \"rgb\", \"hsv\", \"bgr\" (default: \"gray\").\n    cmap (str, optional): Colormap for grayscale images (default: None).\n    cols (int, optional): Number of columns in the grid (default: 2).\n    save_to (str, optional): Path to save the figure (default: None).\n    hspace (float, optional): Vertical spacing between subplots (default: 0.01).\n    wspace (float, optional): Horizontal spacing between subplots (default: 0.01).\n    use_original_style (bool, optional): Keep current Matplotlib style (default: False).\n    invert (bool, optional): Whether to invert images (default: False).</p>\n\n<p>Returns:\n    np.ndarray: Loaded images stacked as an array.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_images([\"img1.png\", \"img2.png\"], color_space=\"rgb\", cols=2)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_paths</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">color_space</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">use_original_style</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.plot_image_with_values", "modulename": "img_phy_sim.img", "qualname": "plot_image_with_values", "kind": "function", "doc": "<p>Plot an image with annotated mean values over non-overlapping blocks.</p>\n\n<p>Each block represents the mean pixel intensity of its region. The mean\nvalues are displayed as text annotations directly on the image.</p>\n\n<p>Parameters:\n    img (np.ndarray): 2D grayscale image (H, W) or 3D single-channel image (H, W, 1).\n    block_size (int or tuple, optional): Size of each block (default: 8).\n    cmap (str, optional): Matplotlib colormap (default: \"gray\").\n    title (str, optional): Plot title (default: None).\n    font_size (int, optional): Font size of value annotations (default: 6).\n    save_to (str, optional): Path to save the figure (default: None).</p>\n\n<p>Returns:\n    None</p>\n\n<p>Example:</p>\n\n<pre><code><div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">imshow</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">plot_image_with_values</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">cv2</span>\n\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;example.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">IMREAD_GRAYSCALE</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Mean Block Values&#39;</span><span class=\"p\">,</span> <span class=\"n\">font_size</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n\n\nOr:\n\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">nrows</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">ncols</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">))</span>\n<span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">img_1</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">input_samples</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Input&quot;</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s2\">&quot;gray&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_1</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_2</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">pred_model</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">model_name</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_2</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_3</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">real</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;ground truth&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_3</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n\n<span class=\"n\">img_4</span> <span class=\"o\">=</span> <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">pred_model</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Difference&quot;</span><span class=\"p\">,</span> <span class=\"n\">sub_image</span><span class=\"o\">=</span><span class=\"n\">real</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">])</span>\n<span class=\"n\">plot_image_with_values</span><span class=\"p\">(</span><span class=\"n\">img_4</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">])</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">block_size</span><span class=\"o\">=</span><span class=\"mi\">8</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">font_size</span><span class=\"o\">=</span><span class=\"mi\">6</span>,</span><span class=\"param\">\t<span class=\"n\">save_to</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.img.show_image_with_line_and_profile", "modulename": "img_phy_sim.img", "qualname": "show_image_with_line_and_profile", "kind": "function", "doc": "<p>Display one or multiple grayscale images with a highlighted line (row or column)\nand plot the corresponding pixel intensity profile below or beside each image.</p>\n\n<p>Parameters:\n    imgs (list[np.ndarray]): List of grayscale images to analyze.\n    axis (str, optional): Direction of the line (\"row\" or \"column\") (default: \"row\").\n    index (int, optional): Index of the selected line. If None, the central line is used (default: None).\n    titles (list[str], optional): Titles for each image (default: [\"Image 1\", \"Image 2\", ...]).\n    figsize (tuple, optional): Figure size per image pair (default: (10, 4)).</p>\n\n<p>Returns:\n    list[np.ndarray]: List of pixel intensity profiles corresponding to the selected line in each image.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>show_image_with_line_and_profile(\n          ...     imgs=[img_input, img_pred, img_gt],\n          ...     axis=\"row\",\n          ...     titles=[\"Input\", \"Prediction\", \"Ground Truth\"]\n          ... )</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">imgs</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;row&#39;</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">titles</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math", "modulename": "img_phy_sim.math", "kind": "module", "doc": "<p><strong>Mathematical and Geometric Utility Functions</strong></p>\n\n<p>This module provides lightweight mathematical helper functions for 2D geometry\nand angle-based computations. It is designed to support higher-level operations\nsuch as beam tracing, image-based simulations, and coordinate normalization.</p>\n\n<p>The functions focus on conversions between angular and Cartesian representations,\nas well as normalization and denormalization of image coordinates.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Generate evenly spaced degree ranges for directional sampling</li>\n<li>Convert between degrees and 2D unit vectors</li>\n<li>Convert 2D vectors back to degree angles</li>\n<li>Normalize and denormalize 2D points for image-based coordinate systems</li>\n</ul>\n\n<p>Typical use cases:</p>\n\n<ul>\n<li>Generating input directions for beam tracing or ray simulation</li>\n<li>Converting between angular and vector representations in geometric algorithms</li>\n<li>Preparing coordinates for normalized image processing workflows</li>\n</ul>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>math</li>\n<li>numpy</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">math</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">pi</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">math_utils</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">get_linear_degree_range</span><span class=\"p\">,</span>\n    <span class=\"n\">degree_to_vector</span><span class=\"p\">,</span>\n    <span class=\"n\">vector_to_degree</span><span class=\"p\">,</span>\n    <span class=\"n\">normalize_point</span><span class=\"p\">,</span>\n    <span class=\"n\">denormalize_point</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Generate sample directions</span>\n<span class=\"n\">directions</span> <span class=\"o\">=</span> <span class=\"n\">get_linear_degree_range</span><span class=\"p\">(</span><span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mi\">45</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert each to a 2D vector</span>\n<span class=\"n\">vectors</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">degree_to_vector</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">directions</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Convert back to degrees</span>\n<span class=\"n\">recovered</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">vector_to_degree</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">vectors</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Normalize and denormalize a point</span>\n<span class=\"n\">p_norm</span> <span class=\"o\">=</span> <span class=\"n\">normalize_point</span><span class=\"p\">((</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">),</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n<span class=\"n\">p_pixel</span> <span class=\"o\">=</span> <span class=\"n\">denormalize_point</span><span class=\"p\">(</span><span class=\"n\">p_norm</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>get_linear_degree_range(...) - Generate evenly spaced degrees within a range.</li>\n<li>degree_to_vector(...)        - Convert a degree angle to a 2D unit vector.</li>\n<li>vector_to_degree(...)        - Convert a 2D vector into its corresponding degree.</li>\n<li>normalize_point(...)         - Normalize a 2D point to [0, 1] range.</li>\n<li>denormalize_point(...)       - Denormalize a 2D point to pixel coordinates.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.math.get_linear_degree_range", "modulename": "img_phy_sim.math", "qualname": "get_linear_degree_range", "kind": "function", "doc": "<p>Generate a list of degrees within a linear range.</p>\n\n<p>Parameters:\n    start (int, optional): Starting degree (default is 0).\n    stop (int, optional): Ending degree (default is 360).\n    step_size (int, optional): Step size between degrees (default is 10).\n    offset (int, optional): Offset to add to each degree value (default is 0).</p>\n\n<p>Returns:\n    list: List of degree values adjusted by offset and modulo 360.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">stop</span><span class=\"o\">=</span><span class=\"mi\">360</span>, </span><span class=\"param\"><span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.degree_to_vector", "modulename": "img_phy_sim.math", "qualname": "degree_to_vector", "kind": "function", "doc": "<p>Convert a degree angle to a 2D unit vector.</p>\n\n<p>Parameters:\n    degree (float): Angle in degrees.</p>\n\n<p>Returns:\n    list: 2D vector [cos(degree), sin(degree)].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">degree</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.vector_to_degree", "modulename": "img_phy_sim.math", "qualname": "vector_to_degree", "kind": "function", "doc": "<p>Convert a 2D vector into its corresponding degree angle.</p>\n\n<p>Parameters:\n    vector (tuple): 2D vector (x, y).</p>\n\n<p>Returns:\n    int: Angle in degrees within the range [0, 360).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.normalize_point", "modulename": "img_phy_sim.math", "qualname": "normalize_point", "kind": "function", "doc": "<p>Normalize a 2D point to the range [0, 1].</p>\n\n<p>Parameters:\n    point (tuple): (x, y) coordinates of the point.\n    width (int): Image or grid width.\n    height (int): Image or grid height.</p>\n\n<p>Returns:\n    tuple: Normalized point (x / (width - 1), y / (height - 1)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.math.denormalize_point", "modulename": "img_phy_sim.math", "qualname": "denormalize_point", "kind": "function", "doc": "<p>Denormalize a 2D point from normalized coordinates back to pixel coordinates.</p>\n\n<p>Parameters:\n    point (tuple): Normalized (x, y) coordinates.\n    width (int): Image or grid width.\n    height (int): Image or grid height.</p>\n\n<p>Returns:\n    tuple: Denormalized point (x * (width - 1), y * (height - 1)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">point</span>, </span><span class=\"param\"><span class=\"n\">width</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing", "modulename": "img_phy_sim.ray_tracing", "kind": "module", "doc": "<p><strong>Beam Tracing and Visualization Utilities</strong></p>\n\n<p>This module provides a set of tools for simulating and visualizing the propagation\nof rays (beams) through 2D images that may contain reflective or obstructive walls.\nIt includes methods for tracing ray paths, handling reflections, scaling and\nnormalizing ray coordinates, and drawing the resulting beam paths onto images.</p>\n\n<p>The core idea is to represent a 2D environment as an image where certain pixel\nvalues correspond to walls or obstacles. Rays are emitted from a relative position\nand traced in specified directions, optionally reflecting off walls multiple times.\nThe results can then be visualized or further processed.</p>\n\n<p>Main features:</p>\n\n<ul>\n<li>Ray tracing with customizable reflection order and wall detection</li>\n<li>Support for relative and absolute coordinate systems</li>\n<li>Ray scaling utilities for normalization or resizing</li>\n<li>Image rendering functions to visualize rays, walls, and reflection paths</li>\n<li>Flexible output modes: single image, multi-channel, or multiple separate images</li>\n</ul>\n\n<p>Typical workflow:</p>\n\n<ol>\n<li>Use <code>trace_beams()</code> to simulate multiple beams across an image.</li>\n<li>Render the rays on an image using <code>draw_rays()</code>.</li>\n</ol>\n\n<p>Dependencies:</p>\n\n<ul>\n<li>numpy</li>\n<li>cv2 (OpenCV)</li>\n<li>internal math + img modules</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;scene.png&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">rays</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">trace_beams</span><span class=\"p\">(</span>\n    <span class=\"n\">rel_position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">),</span>\n    <span class=\"n\">img_src</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"p\">,</span>\n    <span class=\"n\">directions_in_degree</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">45</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">135</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n    <span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"p\">)</span>\n<span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">ray_tracing</span><span class=\"o\">.</span><span class=\"n\">draw_rays</span><span class=\"p\">(</span><span class=\"n\">rays</span><span class=\"p\">,</span> <span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">ips</span><span class=\"o\">.</span><span class=\"n\">img</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Author:<br>\nTobia Ippolito, 2025</p>\n\n<p>Functions:</p>\n\n<ul>\n<li>print_rays_info(...)  - Pritn informations about created rays.</li>\n<li>save(...)  - Save rays into a file.</li>\n<li>open(...)  - Load saved rays.</li>\n<li>merge(...)  - Merge 2 or more rays together.</li>\n<li>get_all_pixel_coordinates_in_between(...)  - Use brahams algorithm for getting any line in a quantizied space.</li>\n<li>get_wall_map(...)  - Extract edges and get the wall-map with direction angles of walls. </li>\n<li>update_pixel_position(...)  - Get the next pixel to come from one point to another in a quantizied system.</li>\n<li>calc_reflection(...)  - Calculate the reflexion of 2 vectors.</li>\n<li>get_img_border_vector(...)  - Get the vector of a border of the image.</li>\n<li>trace_beam(...)  - Trace a single beam with reflexions.</li>\n<li>trace_beams(...)  - Trace multiple beams with reflections through an image.</li>\n<li>scale_rays(...)   - Normalize or rescale ray coordinates.</li>\n<li>draw_rectangle_with_thickness(...) - Draw filled or thick rectangles.</li>\n<li>draw_line_or_point(...) - Draw a single point or a line segment.</li>\n<li>draw_rays(...)    - Visualize traced rays as images or channels.</li>\n</ul>\n"}, {"fullname": "img_phy_sim.ray_tracing.print_rays_info", "modulename": "img_phy_sim.ray_tracing", "qualname": "print_rays_info", "kind": "function", "doc": "<p>Print statistical information about a collection of rays.</p>\n\n<p>Each ray consists of multiple beams, and each beam consists of multiple points.\nThe function computes and displays statistics such as:</p>\n\n<ul>\n<li>Number of rays, beams, reflexions, and points</li>\n<li>Mean, median, max, min, and variance for beams per ray, reflexions per ray, and points per beam</li>\n<li>Value range for x and y coordinates</li>\n</ul>\n\n<p>Parameters:\n    rays (list): Nested list structure representing rays.\n                 Format: rays[ray][beam][point] = (x, y)</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.save", "modulename": "img_phy_sim.ray_tracing", "qualname": "save", "kind": "function", "doc": "<p>Save a list of rays to a text file.</p>\n\n<p>The rays are serialized using a simple text-based format.\nEach ray is delimited by '>' and '&lt;', and each point is represented as \"x | y\".</p>\n\n<p>Parameters:\n    path (str): Path to the file where data should be saved.\n                If no '.txt' extension is present, it will be appended automatically.\n    rays (list): Nested list structure representing rays.\n                 Format: rays[ray][beam][point] = (x, y)</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">rays</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.open", "modulename": "img_phy_sim.ray_tracing", "qualname": "open", "kind": "function", "doc": "<p>Open and parse a ray text file into a structured list.</p>\n\n<p>The file is expected to follow the same format as produced by <code>save()</code>.</p>\n\n<p>Parameters:\n    path (str): Path to the .txt file containing ray data.</p>\n\n<p>Returns:\n    list: Nested list structure representing rays.\n          Format: rays[ray][beam][point] = (x, y)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.merge", "modulename": "img_phy_sim.ray_tracing", "qualname": "merge", "kind": "function", "doc": "<p>Merge multiple ray datasets into a single list.</p>\n\n<p>Parameters:\n    rays_1 (list): First set of rays.\n    rays_2 (list): Second set of rays.\n    *other_rays_ (list): Additional ray lists to merge.</p>\n\n<p>Returns:\n    list: Combined list of all rays.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rays_1</span>, </span><span class=\"param\"><span class=\"n\">rays_2</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">other_rays_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_all_pixel_coordinates_in_between", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_all_pixel_coordinates_in_between", "kind": "function", "doc": "<p>Get all pixel coordinates along a line between two points using Bresenham\u2019s algorithm.</p>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm\">https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a></p>\n\n<p>Parameters:\n    x1 (int): Starting x-coordinate.\n    y1 (int): Starting y-coordinate.\n    x2 (int): Ending x-coordinate.\n    y2 (int): Ending y-coordinate.</p>\n\n<p>Returns:\n    list: List of (x, y) tuples representing all pixels between the start and end points</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span>, </span><span class=\"param\"><span class=\"n\">y1</span>, </span><span class=\"param\"><span class=\"n\">x2</span>, </span><span class=\"param\"><span class=\"n\">y2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_wall_map", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_wall_map", "kind": "function", "doc": "<p>Generate a wall map where each pixel encodes the wall orientation (in degrees).</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Input image representing scene or segmentation mask.\n    wall_values (list, optional): Specific pixel values considered as walls.\n                                  If None, all non-zero pixels are treated as walls.\n    thickness (int, optional): Thickness of wall lines (default is 1).</p>\n\n<p>Returns:\n    numpy.ndarray: 2D array (same width and height as input) where each wall pixel\n                   contains the wall angle in degrees (0\u2013360), and non-wall pixels\n                   are set to infinity (np.inf).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">wall_values</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.update_pixel_position", "modulename": "img_phy_sim.ray_tracing", "qualname": "update_pixel_position", "kind": "function", "doc": "<p>Update the pixel position of a moving point toward a target line based on direction and proximity.</p>\n\n<p>Combines the direction vector with a vector pointing toward the closest point\non the target line, ensuring pixel-wise movement (discrete steps).</p>\n\n<p>Parameters:\n    direction_in_degree (float): Movement direction in degrees.\n    cur_position (tuple): Current pixel position (x, y).\n    target_line (list): Target line defined as [x1, y1, x2, y2].</p>\n\n<p>Returns:\n    tuple: Updated pixel position (x, y).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">direction_in_degree</span>, </span><span class=\"param\"><span class=\"n\">cur_position</span>, </span><span class=\"param\"><span class=\"n\">target_line</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.calc_reflection", "modulename": "img_phy_sim.ray_tracing", "qualname": "calc_reflection", "kind": "function", "doc": "<p>Calculate the reflection of a collision vector against a wall vector.</p>\n\n<p>The reflection is computed using the wall's normal vector and the formula:\n    r = v - 2 * (v \u00b7 n) * n</p>\n\n<p>Parameters:\n    collide_vector (array-like): Incoming vector (2D).\n    wall_vector (array-like): Wall direction vector (2D).</p>\n\n<p>Returns:\n    numpy.ndarray: Reflected 2D vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">collide_vector</span>, </span><span class=\"param\"><span class=\"n\">wall_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.get_img_border_vector", "modulename": "img_phy_sim.ray_tracing", "qualname": "get_img_border_vector", "kind": "function", "doc": "<p>Determine the wall normal vector for an image border collision.</p>\n\n<p>Parameters:\n    position (tuple): Current position (x, y).\n    max_width (int): Image width.\n    max_height (int): Image height.</p>\n\n<p>Returns:\n    list: Border wall vector corresponding to the collision side.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">max_width</span>, </span><span class=\"param\"><span class=\"n\">max_height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.trace_beam", "modulename": "img_phy_sim.ray_tracing", "qualname": "trace_beam", "kind": "function", "doc": "<p>Trace a ray (beam) through an image with walls and reflections.</p>\n\n<p>The beam starts from a given position and follows a direction until it hits\na wall or border. On collisions, reflections are computed using wall normals.</p>\n\n<p>Parameters:\n    abs_position (tuple): Starting position (x, y) of the beam.\n    img (numpy.ndarray): Input image or segmentation map.\n    direction_in_degree (float): Initial direction angle of the beam.\n    wall_map (numpy.ndarray): Map containing wall orientations in degrees.\n    wall_values (list): List of pixel values representing walls.\n    img_border_also_collide (bool, optional): Whether the image border acts as a collider (default: False).\n    reflexion_order (int, optional): Number of allowed reflections (default: 3).\n    should_scale (bool, optional): Whether to normalize positions to [0, 1] (default: True).</p>\n\n<p>Returns:\n    list: Nested list structure representing the traced ray and its reflections.\n          Format: ray[beam][point] = (x, y)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">abs_position</span>,</span><span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">direction_in_degree</span>,</span><span class=\"param\">\t<span class=\"n\">wall_map</span>,</span><span class=\"param\">\t<span class=\"n\">wall_values</span>,</span><span class=\"param\">\t<span class=\"n\">img_border_also_collide</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.trace_beams", "modulename": "img_phy_sim.ray_tracing", "qualname": "trace_beams", "kind": "function", "doc": "<p>Trace multiple rays (beams) from a single position through an image with walls and reflections.</p>\n\n<p>Each beam starts from a given relative position and follows its assigned direction\nuntil it collides with a wall or image border. On collisions, reflections are\ncomputed based on local wall normals extracted from the image.</p>\n\n<p>Parameters:\n    rel_position (tuple): Relative starting position (x, y) in normalized coordinates [0-1].\n    img_src (str or numpy.ndarray): Input image (array or file path) used for wall detection.\n    directions_in_degree (list): List of beam direction angles (in degrees).\n    wall_values (list or float or None): Pixel values representing walls or obstacles.\n    wall_thickness (int, optional): Thickness (in pixels) of detected walls (default: 0).\n    img_border_also_collide (bool, optional): Whether image borders act as colliders (default: False).\n    reflexion_order (int, optional): Number of allowed reflections per beam (default: 3).\n    should_scale_rays (bool, optional): Whether to normalize ray coordinates to [0, 1] (default: True).\n    should_scale_img (bool, optional): Whether to scale the input image before wall detection (default: True).</p>\n\n<p>Returns:\n    list: Nested list of traced beams and their reflection segments.\n          Format: rays[beam][segment][point] = (x, y)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rel_position</span>,</span><span class=\"param\">\t<span class=\"n\">img_src</span>,</span><span class=\"param\">\t<span class=\"n\">directions_in_degree</span>,</span><span class=\"param\">\t<span class=\"n\">wall_values</span>,</span><span class=\"param\">\t<span class=\"n\">wall_thickness</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">img_border_also_collide</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reflexion_order</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_rays</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_img</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.scale_rays", "modulename": "img_phy_sim.ray_tracing", "qualname": "scale_rays", "kind": "function", "doc": "<p>Scale ray coordinates between coordinate systems or image resolutions.</p>\n\n<p>Optionally normalizes rays by old dimensions and rescales them to new ones.\nCan scale all points or just the start/end points of each beam.</p>\n\n<p>Parameters:\n    rays (list): Nested list of rays in the format rays[ray][beam][point] = (x, y).\n    max_x (float, optional): Original maximum x-value for normalization.\n    max_y (float, optional): Original maximum y-value for normalization.\n    new_max_x (float, optional): New maximum x-value after rescaling.\n    new_max_y (float, optional): New maximum y-value after rescaling.\n    detailed_scaling (bool, optional): If True, scale every point in a beam; otherwise, only endpoints (default: True).</p>\n\n<p>Returns:\n    list: Scaled rays in the same nested format.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rays</span>,</span><span class=\"param\">\t<span class=\"n\">max_x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_max_x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_max_y</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">detailed_scaling</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_rectangle_with_thickness", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_rectangle_with_thickness", "kind": "function", "doc": "<p>Draw a filled or thick rectangle on an image.</p>\n\n<p>Expands the given start and end points based on the desired thickness and\nclips coordinates to image bounds to avoid overflow.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image array to draw on.\n    start_point (tuple): Top-left corner of the rectangle (x, y).\n    end_point (tuple): Bottom-right corner of the rectangle (x, y).\n    value (int or float): Fill value or color intensity.\n    thickness (int, optional): Rectangle border thickness; \n                               if &lt;= 0, the rectangle is filled (default: 1).</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">start_point</span>, </span><span class=\"param\"><span class=\"n\">end_point</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_line_or_point", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_line_or_point", "kind": "function", "doc": "<p>Draw either a line or a single point on an image.</p>\n\n<p>Determines whether to draw a point or a line based on whether the start and\nend coordinates are identical.</p>\n\n<p>Parameters:\n    img (numpy.ndarray): Image array to draw on.\n    start_point (tuple): Starting pixel coordinate (x, y).\n    end_point (tuple): Ending pixel coordinate (x, y).\n    fill_value (int or float): Value or color used for drawing.\n    thickness (int): Thickness of the line or point.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img</span>, </span><span class=\"param\"><span class=\"n\">start_point</span>, </span><span class=\"param\"><span class=\"n\">end_point</span>, </span><span class=\"param\"><span class=\"n\">fill_value</span>, </span><span class=\"param\"><span class=\"n\">thickness</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "img_phy_sim.ray_tracing.draw_rays", "modulename": "img_phy_sim.ray_tracing", "qualname": "draw_rays", "kind": "function", "doc": "<p>Render rays onto an image or a set of images.</p>\n\n<p>Each ray can be drawn in full detail (every point) or as straight lines between\nbeam endpoints. Rays can be scaled to match image dimensions and drawn on a\nsingle image, multiple images, or separate channels.</p>\n\n<p>Parameters:\n    rays (list): Nested list of rays in the format rays[ray][beam][point] = (x, y).\n    detail_draw (bool, optional): Whether to draw every point or just beam endpoints (default: True).\n    output_format (str, optional): Output mode: \"single_image\", \"multiple_images\", or \"channels\" (default: \"single_image\").\n    img_background (numpy.ndarray, optional): Background image; if None, a blank image is created.\n    ray_value (int, float, list, or numpy.ndarray, optional): Pixel intensity or color per reflection (default: 255).\n    ray_thickness (int, optional): Thickness of the drawn lines or points (default: 1).\n    img_shape (tuple, optional): Shape of the generated image if no background is given (default: (256, 256)).\n    dtype (type, optional): Data type for the output image (default: float).\n    standard_value (int or float, optional): Background fill value (default: 0).\n    should_scale_rays_to_image (bool, optional): Whether to scale ray coordinates to match the image (default: True).\n    original_max_width (float, optional): Original image width before scaling.\n    original_max_height (float, optional): Original image height before scaling.\n    show_only_reflections (bool, optional): If True, draws only reflected beams (default: False).</p>\n\n<p>Returns:\n    numpy.ndarray or list:\n        - Single image if output_format == \"single_image\" or \"channels\".\n        - List of images if output_format == \"multiple_images\".</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rays</span>,</span><span class=\"param\">\t<span class=\"n\">detail_draw</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">output_format</span><span class=\"o\">=</span><span class=\"s1\">&#39;single_image&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">img_background</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ray_value</span><span class=\"o\">=</span><span class=\"mi\">255</span>,</span><span class=\"param\">\t<span class=\"n\">ray_thickness</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">img_shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">)</span>,</span><span class=\"param\">\tdtype=&lt;class &#x27;float&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">standard_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">should_scale_rays_to_image</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">original_max_width</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">original_max_height</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_only_reflections</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();